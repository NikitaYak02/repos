Весь стандартный ввод — это одна команда (признак конца команды — конец ввода)
шелл должен быть отдельным от утилит, которые вы делали в предыдущем задании. Шелл не должен ничего знать о "каких-то моих mv".
обязательно применение принципов структурного программирования: разбиение на функции, файлы, не использование глобальных переменных и "упрощенных"названий переменных.
Если возникают вопросы, как шелл должен действовать в такой-то ситуации, надо посмотреть, как себя ведет стандартный шелл и сделать по аналогии. Приоритеты операций шелла для рекурсивного спуска можно посмотреть тут: ссылка на gnu.org.
Код завершения шелла формируется по обычным правилам: это код завершения последнего завершившегося потомка или 128 + номер сигнала, если он завершился сигналом. Если произошла ошибка чтения команды (т.е. до запуска первого процесса-потомка), то шелл пишет причину ошибки на стандартный поток ошибок и завершается с кодом 1.
Процесс шелла должна дождаться завершения всех запущенных процессов (даже запущенных в фоне, процессов-внуков и т.п.).
Комментарии по тексту задания:
Конвейер: аргументы у программ в конвейере должны поддерживаться;
Кавычки и эскейп-последовательности в названиях файлов поддерживать не обязательно;
В конъюнкцию и дизъюнкцию можно соединить не только две, а и более команд;
поддерживается точка с запятой (конъюнкция и дизъюнкция по желанию, они не тестируются);
поддерживается конъюнкция (точка с запятой и дизъюнкция по желанию, они не тестируются);
поддерживается дизъюнкция (точка с запятой и конъюнкция по желанию, они не тестируются);
Cкобки должны поддерживаться в любом случае;
Любые пробельные символы - разделители - могут быть в любом количестве и любом месте.
